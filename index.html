  <script>
    let typingLoopActive = true;

    window.onload = function () {
      time();
      typing();
    };

    function typing() {
      const $text = document.querySelector(".typing .text");
      const letters = [
			"쩡햄Live ",
			//"자율적후원 ",
			//"자율적후원 1 2    3    4    5 ",
			//"1 2    3    4    5    6 ",
			//"6 7    8    9    10    11 ",
			"구독좋아요 ",
			"감사합니다 ",
			"다시윤석열 다시대한민국 다시위대하게 YOONAGAIN"
      ];

      const wordList = [
        { words: ["L", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "후원", "구독", "감사", "YOON", "다시"], color: "red" },
        { words: ["AGAIN"], color: "#6495ED" }
      ];

      const speed = 100;
      let i = 0;

      const typingFunc = async () => {
        if (!typingLoopActive) return;
        $text.innerHTML = "";
        const raw = letters[i];
        const typingChars = [];
        const consumed = Array(raw.length).fill(false);

        for (const group of wordList) {
          for (const word of group.words) {
            let startIndex = 0;
            while (startIndex < raw.length) {
              const index = raw.indexOf(word, startIndex);
              if (index === -1) break;
              for (let j = 0; j < word.length; j++) {
                typingChars[index + j] = { char: word[j], color: group.color };
                consumed[index + j] = true;
              }
              startIndex = index + 1;
            }
          }
        }

        for (let j = 0; j < raw.length; j++) {
          if (!consumed[j]) {
            typingChars[j] = { char: raw[j], color: "white" };
          }
        }

        for (const { char, color } of typingChars) {
          if (!typingLoopActive) return;
          await wait(speed);
          const span = document.createElement("span");
          span.textContent = char;
          span.style.color = color;
          $text.appendChild(span);

          const rect = span.getBoundingClientRect();
          const x = rect.left + rect.width / 2 + window.scrollX;
          const y = rect.top + rect.height / 2 + window.scrollY + 10;

          createBricksBatch(x, y, color, 10);
        }

        await wait(14000);
        remove();
      };

      const remove = async () => {
        const spans = Array.from($text.childNodes).reverse();
        while (spans.length) {
          if (!typingLoopActive) return;
          await wait(speed);
          const span = spans.shift();
          if (span && span.getBoundingClientRect) {
            const rect = span.getBoundingClientRect();
            const x = rect.left + rect.width / 2 + window.scrollX;
            const y = rect.top + rect.height / 2 + window.scrollY + 10;

            createBricksBatch(x, y, span.style.color, 10);
          }
          if (span) span.remove();
        }

        i = (i + 1) % letters.length;
        typingFunc();
      };

      function wait(ms) {
        return new Promise((res) => setTimeout(res, ms));
      }

      if (window.requestIdleCallback) {
        requestIdleCallback(typingFunc); // ✅ 변경된 부분
      } else {
        setTimeout(typingFunc, 1000); // fallback
      }
    }

    (function () {
      const brickPool = [];
      const MAX_POOL = 100;

      function getBrick() {
        if (brickPool.length > 0) {
          return brickPool.pop();
        }
        const div = document.createElement("div");
        div.className = "brick";
        return div;
      }

      function recycleBrick(brick) {
        brick.style.display = "none";
        brick.style.opacity = 1;
        brick.fading = false;

        // 순환 참조 해제
        if (brick.__data__) {
          brick.__data__.element = null;
          brick.__data__ = null;
        }

        brickPool.push(brick);

        // 과잉 브릭 전부 제거
        while (brickPool.length > MAX_POOL) {
          const removed = brickPool.pop();
          removed.remove();
        }
      }

      const activeBricks = [];
      let isAnimating = false;

      function animateBricks() {
        const gravity = 0.5;
        const friction = 0.6;

        for (let i = activeBricks.length - 1; i >= 0; i--) {
          const b = activeBricks[i];
          if (!b.falling) continue;

          b.dy += gravity;
          b.posX += b.dx;
          b.posY += b.dy;

          if (b.posY >= b.ground) {
            b.posY = b.ground;
            b.dy = 0;
            b.dx *= friction;
            if (Math.abs(b.dx) < 0.1) b.dx = 0;

            if (!b.fading) {
              b.fading = true;
              b.fadeOpacity = 1;
            }
          }

          b.element.style.left = b.posX + "px";
          b.element.style.top = b.posY + "px";

          if (b.fading) {
            b.fadeOpacity -= 0.05;
            if (b.fadeOpacity <= 0) {
              b.fading = false;
              b.falling = false;

              recycleBrick(b.element);
              activeBricks.splice(i, 1);
              continue;
            } else {
              b.element.style.opacity = b.fadeOpacity;
            }
          }
        }

        if (activeBricks.length > 0) {
          requestAnimationFrame(animateBricks);
        } else {
          isAnimating = false;
        }
      }

      window.createBricksBatch = function (x, y, color = "white", count = 10) {
        const fragment = document.createDocumentFragment();
        const bricksToAnimate = [];

        for (let i = 0; i < count; i++) {
          const brick = getBrick();
          brick.style.left = x + "px";
          brick.style.top = y + "px";
          brick.style.background = color;
          brick.style.border = "1px solid black";
          brick.style.opacity = 1;
          brick.style.display = "block";

          fragment.appendChild(brick);

          const dx = (Math.random() - 0.5) * 6;
          const dy = (Math.random() - 1.5) * 6;

          const brickData = {
            element: brick,
            posX: x,
            posY: y,
            dx: dx,
            dy: dy,
            ground: y,
            fading: false,
            fadeOpacity: 1,
            falling: true,
          };

          // 순환 참조 해제를 위해 brick에 데이터 직접 연결
          brick.__data__ = brickData;

          bricksToAnimate.push(brickData);
        }

        document.body.appendChild(fragment);

        activeBricks.push(...bricksToAnimate);

        if (!isAnimating) {
          isAnimating = true;
          requestAnimationFrame(animateBricks);
        }
      };
    })();

    function time() {
      const today = new Date();
      const hours = ("0" + today.getHours()).slice(-2);
      const minutes = ("0" + today.getMinutes()).slice(-2);
      document.getElementById("time").innerHTML = hours + ":" + minutes;
    }

    const timeInterval = setInterval(time, 60000);

    // ✅ 메모리 릭 방지
    window.addEventListener("unload", function () {
      clearInterval(timeInterval);
      typingLoopActive = false;
      window.createBricksBatch = () => {};
    });
  </script>
  <style>
    .typing {
      position: relative;
    }
    .brick {
      position: absolute;
      width: 12px;
      height: 12px;
      background: white;
      border: 1px solid black;
      border-radius: 3px;
      pointer-events: none;
      z-index: 9999;
      opacity: 1;
      will-change: transform, opacity;
    }
  </style>
<body>
  <br>
  <table border="0">
    <tr>
      <td width="975" style="vertical-align: top; text-align: right; white-space: nowrap; overflow: hidden; max-width: 975px; padding-left: 0px; padding-right: 85px;">
        <span class="typing" style="color: white; font-size: 45px; font-weight: bold; font-family: hy울릉도b; text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black;">
          <span id="textcolor" class="text"></span>
        </span>
        <span style="color: white; font-size: 45px; font-weight: bold; font-family: hy울릉도b; text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black;visibility:hidden;">
          <font color="#FFD700">&ensp;&ensp;&ensp;카카오</font> 33330-7696-7896 <font color="#6495ED">오J한</font>
        </span>
      </td>
      <td style="vertical-align: top; text-align: right; padding-top: 12px; padding-left: 50px;">
        <span id="time" style="color: white; font-size: 45px; font-weight: bold; font-family: hy울릉도b; text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black;"></span>
      </td>
    </tr>
  </table>
</body>
